sampler s0 : register(s0);
sampler s1 : register(s1);
sampler s2 : register(s2);
float4 p0 : register(c0);
float4 p1 : register(c1);
float4 p2 : register(c2);

#define PI acos(-1)
#define C1 (16.0/255.0)

#define width (p0[0])
#define height (p0[1])
#define t_width (p0[2])
#define t_height (p0[3])

#define repeat_x (p0[0])
#define repeat_y (p0[1])

#define dx (1/width)
#define dy (1/height)
#define px (1/t_width)
#define py (1/t_height)

float4 main(float2 tex : TEXCOORD0) : COLOR
{
	if (tex.x > 0.5) tex.x -= 0.5;
	return tex2D(s0, tex);

	//float c0 = 1-dot(tex2D(s0, tex), float4(0.299, 0.587, 0.114, 0));	
	//float c0 = dot(tex2D(s0, tex), float4(0.333, 0.333, 0.333, 0));	
	//return float4(c0, c0, c0, 1);

	//float4 c0 = float4(1, 1, 1, 2) - tex2D(s0, tex);
	//return c0;

	//return float4(1,tex.x,tex.y,1);
}


float4 yuv2rgb(float4 yuv)
{
	yuv.r -= C1;
	yuv.g -= 128.0/255.0;
	yuv.b -= 128.0/255.0;

	/*
	// hue
	float hue = 0.0/4.0*PI;
	float gg = (yuv.g) * cos(hue) - (yuv.b) * sin(hue);
	float bb = (yuv.b) * cos(hue) + (yuv.g) * sin(hue);
	yuv.g = gg;
	yuv.b = bb;
	
	// Saturation
	float saturation = 1.0;
	yuv.g *= saturation;
	yuv.b *= saturation;
	
	// luma
	float luma = 1.0;
	yuv.r *= luma;
	yuv.g *= luma;
	yuv.b *= luma;

	// final clipping
	yuv.r = clamp(yuv.r, 0, 1);
	yuv.g = clamp(yuv.g, -0.5, 0.5);
	yuv.b = clamp(yuv.b, -0.5, 0.5);
	*/
	
	float4x4 coeffs2=
		{
			 1.164, 0.000, 1.596, 0.000,
			 1.164,-0.391,-0.813, 0.000,
			 1.164, 2.018, 0.000, 0.000,
			 0.000, 0.000, 0.000, 1.000
		};
	
	return (mul(coeffs2,yuv));
}

float4 main3(float2 tex : TEXCOORD0) : COLOR
{
	float2 texY = tex;
	texY.y /= 1.5;

	float2 texV = tex;
	texV.y = texV.y / 6.0 + (2.0/3.0);

	float2 texU = tex;
	texU.y = texU.y / 6.0 + (2.5/3.0);
	
	//return tex2D(s0, tex);
	return yuv2rgb(float4(tex2D(s0, texY).r, tex2D(s0, texV).r, tex2D(s0, texU).r, 1));
}

float2 Y2Tex(float2 Y)
{
	float xx = Y.x/t_width + 0.5/t_width;
	float yy = Y.y/t_height + 0.5/t_height;
	return float2(xx, yy);
}

float4 NV12toRGB_1plane(float2 tex : TEXCOORD0) : COLOR		//NV12
{
	int x1 = floor((tex.x - 0.5/width) * width + 0.5);
	int y1 = floor((tex.y - 0.5/height) * height + 0.5);		// (x1,y1) : coordinate in Y plane
	
	int x2 = x1/2;
	int y2 = y1/2;
	
	int x3 = x2*2;
	int y3 = y2;
	
	float2 tex_y = Y2Tex(float2(x1, y1));
	float2 tex_v = Y2Tex(float2(x3+1, y3+height));
	float2 tex_u = Y2Tex(float2(x3, y3+height));
		
	return yuv2rgb(float4(tex2D(s0, tex_y).r, tex2D(s0, tex_u).r, tex2D(s0, tex_v).r, 1));
}

float4 planar_rgb_yv12(float2 tex : TEXCOORD0) : COLOR
{
	int x1 = floor((tex.x - 0.5/width) * width + 0.5);
	int y1 = floor((tex.y - 0.5/height) * height + 0.5);		// (x1,y1) : coordinate in Y plane
	
	int x2 = x1/2;
	int y2 = y1/2;
	
	int x3 = x2;
	//if (y2 % 2 != 0) x3 += width/2;
	x3 += width/2*(y2%2);
	int y3 = y2/2;
	
	float2 tex_y = Y2Tex(float2(x1, y1));
	float2 tex_v = Y2Tex(float2(x3, y3+height));
	float2 tex_u = Y2Tex(float2(x3, y3+height*5/4));
	
	return yuv2rgb(float4(tex2D(s0, tex_y).r, tex2D(s0, tex_u).r, tex2D(s0, tex_v).r, 1));
}

float4 YV12toRGB(float2 tex : TEXCOORD0) : COLOR
{
	float2 tex_v = {tex.x, tex.y/2};
	float2 tex_u = {tex.x, tex.y/2+0.5};
		
	return yuv2rgb(float4(tex2D(s0, tex)[0], tex2D(s1, tex_u)[0], tex2D(s1, tex_v)[0], 1));
}

float4 YUY2toRGB(float2 tex : TEXCOORD0) : COLOR
{
	float4 uv = tex2D(s0, tex);		//u:1,v:3
	int x2 = floor((tex.x - 0.5/(width)) * (width) + 0.5);
	
	int x = floor((tex.x - 0.5/t_width) * t_width + 0.5);
	float x1 = x/t_width + 0.5/t_width;
	float4 y4 = tex2D(s0, float2(x1, tex.y));
		
	if (x2%2==0)
		return yuv2rgb(float4(y4[2], uv[1], uv[3],1));
	else
		return yuv2rgb(float4(y4[0], uv[1], uv[3],1));
		
	return yuv2rgb(float4(tex2D(s0, tex)[0], tex2D(s1, tex)[1], tex2D(s1, tex)[3], 1));
}

float4 anaglyph(float2 tex : TEXCOORD0) : COLOR
{
	//float2 delta = float2((1-tex.y)*0.004+0.002, 0);
	//float2 delta = 0;

	float4 l = tex2D(s0, tex);
	float4 r = tex2D(s1, tex);
	
	r.r = 0;
	l.r = 0.299 * l.r + 0.587 * l.g + 0.114 * l.b;
	l.g = 0;
	l.b = 0;
	
	return l + r;
}

float4 NV12toRGB(float2 tex : TEXCOORD0) : COLOR		//NV12
{
	return yuv2rgb(float4(tex2D(s0, tex)[0], tex2D(s1, tex)[0], tex2D(s1, tex)[3], 1));
}


#define tx (p0[0])
#define ty (p0[1])
#define sx (p0[2])
#define sy (p0[3])

#define cx (p1[0])
#define cy (p1[1])
#define rx (p1[2])
#define ry (p1[3])

#define v (p2[0])
#define a (p2[1])
float4 UI(float2 tex : TEXCOORD0) : COLOR
{
	float2 sv = {sx/tx, sy/ty};
	float2 cv = {cx/tx, cy/ty};
	
	float2 pv = {frac(tex.x*rx)*cv.x, frac(tex.y*ry)*cv.y};
	pv += sv;
	if (tex.x>v)
		pv += cv;
	
	float4 o = tex2D(s0, pv);
	o[3] *= a;
	return o;
}


// vs_subtitle

#define sx2 (p0[0])
#define sy2 (p0[1])
#define cx2 (p0[2])
#define cy2 (p0[3])
#define tsx (p1[0])
#define tsy (p1[1])
#define tcx (p1[2])
#define tcy (p1[3])
struct VS_OUTPUT
{
	float4 position : POSITION;
	float2 tex : TEXCOORD0;
};
VS_OUTPUT vs_subtitle(VS_OUTPUT IN)
{
	VS_OUTPUT o;
	o.position.z = IN.position.z;
	o.position.w = 1;
	o.position.x = IN.position.x * cx2 + sx2;
	o.position.y = IN.position.y * cy2 + sy2;
	o.tex.x = IN.tex.x * tcx + tsx;
	o.tex.y = IN.tex.y * tcy + tsy;
	
	return o;
}


// IZ3D
float4 iz3d_front(float2 tex : TEXCOORD0) : COLOR
{
	float4 l = tex2D(s0, tex);
	float4 r = tex2D(s1, tex);
	
	float ly = 0.299 * l.r + 0.587 * l.g + 0.114 * l.b;
	float ry = 0.299 * r.r + 0.587 * r.g + 0.114 * r.b;

	float o = 0.5;
	
	if (ly + ry > 0.02)
		o = ry/(ly+ry);
	
	return o;
	return o * (l+r);
}

float4 iz3d_back(float2 tex : TEXCOORD0) : COLOR
{
	float4 l = tex2D(s0, tex);
	float4 r = tex2D(s1, tex);
	
	return (l+r)/2;
}


// simple yuv-rgb convertion
float4 rgb2yuv2(float4 rgb)
{
	float4x4 coeffs=
		{
			 0.299, 0.587, 0.114, 0.000,
			-0.147,-0.289, 0.436, 0.000,
			 0.615,-0.515,-0.100, 0.000,
			 0.000, 0.000, 0.000, 0.000
		};
		
	return mul(coeffs,rgb);
}

float4 yuv2rgb2(float4 yuv)
{
	float4x4 coeffs=
		{
			 1.000, 0.000, 1.140, 0.000,
			 1.000,-0.395,-0.581, 0.000,
			 1.000, 2.032, 0.000, 0.000,
			 0.000, 0.000, 0.000, 0.000
		};
	
	return mul(coeffs,yuv);
}


#define saturation (p0[0])
#define luminance (p0[1])
#define hue01 (p0[2])
#define contrast (p0[3])

float4 color_adjust(float2 tex : TEXCOORD0) : COLOR
{
	float4 rgb = tex2D(s0, tex);
	float4 yuv = rgb2yuv2(rgb);
	
	float sat = exp((saturation - 0.5)*(saturation>0.5?3:3));	// 
	float lum = luminance - 0.5;	// 
	float hue = (hue01 - 0.5) * 2 * PI;	// 
	float con = exp((contrast - 0.5)*(contrast>0.5?1:1));	// 
	
	// do hue and sat in yuv color space	
	
	// hue
	float gg = (yuv.g) * cos(hue) - (yuv.b) * sin(hue);
	float bb = (yuv.b) * cos(hue) + (yuv.g) * sin(hue);
	yuv.g = gg;
	yuv.b = bb;
	
	// saturation
	yuv.g *= sat;
	yuv.b *= sat;

	// do lum and con in rgb color space
	rgb = yuv2rgb2(yuv);
	
	// luminance
	rgb += lum;
	
	// contrast
	rgb.r = 0.5 + (rgb.r-0.5) * con;
	rgb.g = 0.5 + (rgb.g-0.5) * con;
	rgb.b = 0.5 + (rgb.b-0.5) * con;
	
	// set Alpha to 1.0
	rgb[3] = 1.0;
	
	return rgb;
}